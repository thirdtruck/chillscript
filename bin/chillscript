#!/usr/bin/env ruby

require 'pp'

def compilation_error(error_description)
  puts "My bad. #{error_description}"
  exit
end

class ChillPattern
  attr_reader :conditions
  attr_reader :responses

  def initialize(conditions=[], responses=[])
    @conditions = conditions
    @responses = responses
  end
end

class ChillVirtualMachine
  def initialize(script)
    @script = script
    @state = {}
    @patterns = []
  end

  def new_pattern(condition)
    if @current_pattern
      compilation_error "I think you're trying to start a new pattern, but haven't finished with the current one. Could you put an empty line before this so I don't get confused? Thanks! Line: #{line}"
    else
      @current_pattern = ChillPattern.new([condition])
    end
  end

  def run
    @script.each_line do |line|
      case line
      when /^when (.*)/
        condition = $1
        new_pattern(condition)
      when /^and (.*)/
        condition = $1
        if @current_pattern
          @current_pattern.conditions << condition
        else
          compilation_error "I think you're trying to make a pattern more specific, but I can't see where the pattern started. I'm confused by: #{line}"
        end
      when /^$/ # Empty line signifies the end of a pattern
        if @current_pattern
          @patterns << @current_pattern
          @current_pattern = nil
        end
      when /^  (.*)/
        response = $1
        if @current_pattern
          @current_pattern.responses << response
        else
          compilation_error "I could be wrong, but I think you're trying to write a response to a pattern that isn't there? Did you mean to indent this? #{line}"
        end
      else
        compilation_error "I don't understand this: #{line}"
      end
    end

    if @current_pattern
      @patterns << @current_pattern
    end

    match_against_start_program

    puts "Under construction, buddy."
  end

  def match_against_start_program
    @patterns.each do |pattern|
      pattern.conditions.each do |condition|
        if condition =~ /START-PROGRAM/
          run_responses(pattern.responses)
        end
      end
    end
  end

  def run_responses(responses)
    responses.each { |response| puts "Responding with: #{response}" }
  end
end

script = <<SCRIPT
when greeting exists
and time-to-greet is true
  print greeting

when START-PROGRAM
  greeting becomes "Hello, World!"
  time-to-greet becomes true
SCRIPT

vm = ChillVirtualMachine.new(script)
output = vm.run
puts output
